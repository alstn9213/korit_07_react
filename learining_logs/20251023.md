# Login Process 진행
# REST API 호출

현재 상황에서 로그인을 성공한다고 하더라도 jwt를 세션스토리지에 저장했을 분이고, 아직 getCars()의 결과값을 가져오지는 못한다.
이 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지고 frontend상에서 Carlist를 불러오지 못하고 있는 상황이기 때문이다.
carapi.ts에 getCars() 호출할 때 얻어온 jwt를 사용해야하기 때문이다.
근데 jwtToken 값이 생각해보면 .then()이 걸려있기때문에 일종의 지역변수라고 볼 수 있다. 그렇다면 Login 컴포넌트를 벗어나서는 사용할 수 없다는 의미가 될것이다.
그러면 얘를 어떻게 끌고 와서 getCars() 함수에 jwt값을 넣어서 같이 GET 요청을 보낼 수 있을지 고민만 해보겠다.

우리가 sessionStorage에 굳이 setItem을 한 이유에 대해 생각해봐야한다. -> carapi.ts에서 쓰려고.

그래서 api들에 token집어넣는거 하고나서는 중복 코드를 리택토링할 예정이다. 지금보면 결과적으로 token을 함수들에서 전부 다 꺼내쓰고 있는 중인데다가 Authorization : token 뭐 이런 부분이 반복적으로 쓰이는 것을 확인할 수 있다.

```tsx
//  api/carapi.ts 파일 생성
import axios from "axios";
import { Car, CarResponse, CarEntity } from "../types";

export const getCars = async(): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');
    // 세션 스토리지 상에 'Bearer ' 가 포함되어있다. Postman에서 요청날릴때 'Bearer ' 부분을 빼놓고 붙여넣기 했던것을 떠올려서 프론트엔드 상에서 'Bearer '를 제거하고 그걸 기준으로 요청을 날렸다.
    const rawToken = token?.replace('Bearer ', '');
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
      headers: { 'Authorization': `${rawToken}` }
    });
    
    return response.data._embedded.cars;
  }

export const deleteCar = async (link: string): Promise<CarResponse> => {
  // chaining method 활용한 코드도 하나는 남겨놓겠다.
  const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');
  const response = await axios.delete(link, {
    headers: { 'Authorization': `${token}` }
  });
  return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
  const token = sessionStorage.getItem('jwt');
  const rawToken = token?.replace('Bearer ', '');
  const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': rawToken
    },
  });
  return (response).data;
}

export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
  const token = sessionStorage.getItem('jwt');
  const rawToken = token?.replace('Bearer ', '');
  const response = await axios.put(carEntity.url, carEntity.car, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': rawToken

    },
  });
  return response.data;
}
```

이상은 refactoring 전 부분이다. 위에 말했던 것처럼 token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를 제거하는 부분, 그리고 headers 내에 'Authorization' : token 부분이 중복되고 있다는 것을 확인할 수 있다.
이 부분에서 알아야할 점은 Scope 개념이다. 각 함수의 내부에서 token을 선언하고 Bearer 접두사를 제거하고 있기 때문에 함수마다 선언 및 초기화를 하는 것 같다.

## 중복 코드 리팩토링

```tsx
//  api/carapi.ts 파일 생성
import axios, {AxiosRequestConfig} from "axios";
import { Car, CarResponse, CarEntity } from "../types";

const getAxiosConfig = () : AxiosRequestConfig => {
  const token = sessionStorage.getItem('jwt')?.replace('Bearer ', '');
  return {
    headers: {
      'Authorization' : token,
      'Content-Type': 'application/json',
    },
  };
};

export const getCars = async(): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, getAxiosConfig());
    
    return response.data._embedded.cars;
  }

export const deleteCar = async (link: string): Promise<CarResponse> => {
  const response = await axios.delete(link, getAxiosConfig());
  return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {
  const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, getAxiosConfig());
  return (response).data;
}

export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
  const response = await axios.put(carEntity.url, carEntity.car, getAxiosConfig());
  return response.data;
}
```
이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig이다.

- AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때, 사용되는 구성 객체 타입 정의에 해당한다. 즉, Axios를 경유하여 요청을 보내기위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당한다.
- axios.post(), .get ...과 같은 방식으로 사용한다. 이는 좀 더 가독성을 높이기 위한 방식으로 _메서드 별 요청_ 에 해당한다. 이 경우 endpoint 다음에 두 번째 argument로 사용된다.

```ts
// GET 요청이라고 가정
axios.get('http://localhost:8080/api/cars', {headers:{'Authorization':token}});
```

2. 일반적인 요청방식이 있다.
```ts
axios({
  method: 'get',
  url: 'http://localhost:8080/api/cars',
  headers: {
    'Authorization': token,
  }
});
```
이상의 1, 2 과정 중에 return 타입에 객체 형태로 집어넣는 옵션들을 담을 수 있는 것을 AxiosRequestConfig 라고 한다. 우리는 1번 방법을 사용했기 때문에 getAxiosConfig()함수의 정의가 간단한 편에 속헀다. 2번 방법이면 method 키의 value를 지정하는게 복잡했겠다.

인터셉터(interceptor)에서의 활용: request interceptor는 요청이 서버로 가기전에 가로채서 구성을 수정한다. 즉, getAxiosConfig()  함수 요청을 하면 처음에는 token이 없는 상태로 DB까지 가게 될 뻔했는데, 중간에 가로채서 headers를 추가해준다는 의미이다.

## Authentication 실패시 오류 메시지를 토스트 메시지로 응용하겠다.

```tsx
 <Snackbar 
        open={open}
        autoHideDuration={3000}
        onClose={() => setOpen(false)}
        message='ID 혹은 비밀번호가 틀렸습니다.'
      />
```
라고 설정했다고 가정했을 때, 우리는 setOpen(true)를 호출하는 부분이 필요할 듯하다. Login 컴포넌트 중 어떤 동작을 했을 때, toast message가 출력되어야하며, 그래서 setOpen(true) 코드를 삽입해야하는 부분은 어디일까.
