# 금일 계획
1. C 관련 부분 MUI 컴포넌트로 대체
2. U부분 구현
3. Button 및 MUI Icons 도입
4. Frontend 로그인 관련 로직

## 코드 리팩토링 관련
현재 New Car 버튼을 클릭했을 때, Modal이 나오면서 빈 input 태그들이 뜬다. 여기에 정보를 입력할 수 있는 상태이다.
그런데 각 row의 맨 마지막 컬럼으로 Edit 버튼을 추가해서 일부 수정을 가능하게끔 할 예정이다. 그리고 이때도 Modal이 뜨게끔 할 것이다.
그렇다면 New Car에서 사용하는 Modal을 Edit에서도 동일하게 쓸 수 있을 것 같다. 블로그를 작성할 때, 새로 발행하기만 하면 빈 양식으로 뜨는데,
수정하기 하면 똑같은 양식이 나오지만 내용 그대로 나오는 것과 동일하다고 할 수 있다.

components 폴더 내에 CarDialogContent.tsx 파일을 생성

```tsx
//  CarDialogContent
import { ChangeEvent } from "react";
import { Car } from "../types";

type DialogFormProps = {
  car: Car;
  handleChange: (event: ChangeEvent<HTMLInputElement>) => 
    void;

}

function CarDialogContent({car, handleChange}: DialogFormProps) {
  return(<></>);
}

export default CarDialogContent
```

현재 CarDialogContent 컴포넌트를 초기화했다.
현재의 목표는 New Car 폼의 TextField를 렌더링하는 새 컴포넌트를 만들어서 Edit 폼에도 사용하는 것이다.
그래서 TextField에 해당하는 부분을 자체 컴포넌트로 만들기위해 CarDialogContent를 새로만들었다. 그리고 props를 이용해 컴포넌트에
car객체와 handleChange 함수를 전달해야한다.(AddCar 컴포넌트에 정의돼있다.). 이를 위해 DialogFormProps type을 정의해뒀다. 얘를 types.ts로 분리하지않은 이유는
얘를 Edit에 쓸지 안쓸지 모르기때문이다.

## 수정 기능 추가
Edit 버튼의 경우 위치가 New Car와 동일해서는 안된다. {id}에 맞는 부분을 수정해야하기 때문에, 각 row 옆에다가 Edit 버튼을 추가할 것이다.

```tsx
// EditCar.tsx
import { ChangeEvent, useState } from "react";
import { Car, CarResponse } from "../types";
import { Dialog, DialogActions, DialogTitle } from "@mui/material";
import CarDialogContent from "./CarDialogContent";

type FormProps = {
  cardata: CarResponse
}

function EditCar({cardata}: FormProps) {
  const [open, setOpen] = useState(false);
  const [car, setCar] = useState<Car>({
    brand: '',
    model: '',
    color: '',
    registrationNumber: '',
    modelYear: 0,
    price: 0
  });

  const handleClickOpen = () => {
    setOpen(true);
    // Modal이 열렸을 때, 특정 id값에 맞는 정보를 불러오면 좋겠다. 그래서 AddCar에서의 handleClickOpen()과 코드라인의 차이가 생긴다.
    setCar({
      brand: cardata.brand,
      model: cardata.model,
      color: cardata.color,
      registrationNumber: cardata.registrationNumber,
      modelYear: cardata.modelYear,
      price: cardata.price
    })
  };

  const handleClickClose = () => {
    setOpen(false);
  }

  const handleSave = () => {
    setOpen(false);
  }

  // AddCar.tsx에서 그대로 복사해왔다.
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setCar({...car, [event.target.name]: event.target.value});
  }

  return(<>
    <button onClick={handleClickOpen}>
      Edit
    </button>
    <Dialog open={open} onClose={handleClickClose}>
      <DialogTitle>Edit Car</DialogTitle>
      <CarDialogContent car={car} handleChange={handleChange}>
        
        </CarDialogContent> 
      <DialogActions>
        <button onClick={handleClickClose}>Cancel | 취소</button>
        <button onClick={handleSave}>Save | 저장</button>
      </DialogActions>
    </Dialog>
  </>)

}

export default EditCar
```

이상의 EditCar 컴포넌트를 Carlist 컴포넌트에 집어넣었다. 특정 id 값을 받아내기위해서 GridColDef 부분에 새로 컬럼 정의를 해줬고, renderCell을 이용하여 이상의 컴포넌트를 불러냈다.
이 부분까지 작성했을 때, frontend 상에서 edit 버튼이 생겨나고, 그걸 클릭했을 때, Modal창이 뜬다는 것을 확인할 수있다. 그 모달 창은 CarDialogContent 컴포넌트고, AddCar에서 사용했던것과 동일하기 때문에 컴포넌트가 재사용성이 있다는 점을 확인할 수 있다. 

차이점이 있다면 각각의 input 태그 내에 AddCar 컴포넌트에서는 전부 값이 비워져있던 반면에 EditCar에서는 어떤 row를 클릭했는지에 따라 값이 서로 다르게 input 태그 내에 들어가있었다.
이는 마찬가지로 renderCell이 (params)를 매개변수로 갖기때문이다. params.row를 하면 테이블 내의 각 row들을 지칭하게 된다.
이제 고려해야하는 부분은 브라우저 상에서 수정된 자동차 정보를 백엔드로 보내줘야 한다는 점이다. http://localhost:8080/api/cars/{id}로 PUT 요청을 보내게 될것이다.
삭제할때 href값을 가져왔기 때문에 동일한 기능을 한다는 것을 알 수 있다.
차이점이 있다면 deleteCar()는 id값만 보내면 되는 반면에 updateCar()의 경우는 수정할 id값과, 수정 내용이 전달되어야하기 때문에 매개변수 개수가 달라질것이다. 이 부분도 backend에서의 CarController를 확인하자(cardatabase4 기준이다. 2에는 없음).
여기 요청의 경우에는 내용이 필요하기 때문에 addCar()에서와 마찬가지로 `Content-Type`: `application/json` headers가 필요하다.

새로운 자료형을 정의했다.
```ts
export type CarEntity = {
  car: Car;
  url: string;
}
```

이후 carapi.ts에서 함수를 생성해서 export 시킬것이고, 그 함수는 EditCar 컴포넌트에서 사용할 예정이다.

```ts
// carapi.ts
export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
  const response = await axios.put(carEntity.url, carEntity.car, {
    headers: {
      'Content-Type': 'application/json'
    },
  });
  return response.data;
}
```

이상의 코드는 addCar() 함수와 비슷한 부분들이 있다. 하지만 axios.put() 요청에서의 첫번째 argument가 변수를 통해 불러와진다는 점에서의 차이점이 있다. 왜냐면 애초에 차량 정보가 DB에 저장돼있기 때문에 endpoint가 id값까지 생성돼있다. 그리고 우리는 이것을 삭제할 때 alert()를 통해 href값을 가지고올 수 있다는 것을 확인했다. 그래서 굳이 `${import.meta.env.VITE_API_URL}/api/cars/${carEntity.id}` 와 같은 식으로 작성할 필요가 없다.

## CSV로 데이터 내보내기
MUI 데이터 그리드에서 CSV(Comma Seperated Values) 데이터 내보내기 기능을 지원하기 때문에 추가 라이브러리의 설치가 필요없다.

그럼 위에서 데이터그리드에서 가지고 올거라고 했으니까 기본적으로 Carlist 컴포넌트에서 작성할 것이라고 알 수 있겠다.

버전이 x-data-grid가 7버전 이후 부터는 GridToolbar를 지원하지 않기때문에 패키지 삭제를 실습힌다.
uninstall @mui/x-data-grid
특정 버전을 명시하여 설치
npm install @mui/x-data-grid@6.16.2

git add . 
git commit -m "feat: x-data-grid version control 6.16.2"
git push

html태그들 MUI로 갈아끼우는 부분 들어간다.

# MUI 활용 프론트엔드 꾸미기
1. Button 컴포넌트 - AddCar / EditCar 컴포넌트의 button을 Button으로 갈아끼웠다.
2. TextField 컴포넌트 
3. Icon / IconButton 컴포넌트


icon 도입한다.
npm install @mui/icons-material@5.17.1
이상의 icon 패키지는 Delete 버튼을 아이콘버튼 형태로 사용하기 위해 도입했다.
아이콘 종류가 많으므로 레퍼런스
http://mui.com/material-ui/material-icons
이상으로 들어가면 import 해올 아이콘 목록이 있다. 도입 방식은 좀 있다  설명할텐데, MUI관련된 공식 문서기 때문에 혹시 팀 프로젝트 중에 MUI를 기준으로 CSS를 꾸밀 생각이 있다면 즐겨찾기 추천한다.

git add . 
git commit -m "feat: before edit button"
git push