# third party components
chrome -> awesome react-components
https://github.com/brillout/awesome-react-components

1. 컴포넌트들은 README에서 볼 수 있듯이 npm을 통해 설치가 가능하다.
설치 방법 : `npm install component_name@version`
`npm install react-date-picker@10.0.3`
- 설치된 컴포넌트를 리액트 앱에서 제거하는 명령어
`npm uninstall component_name`
`npm uninstall react-date-picker`
- 업데이트가 누락된 컴포넌트들을 전부 다 검색하는 명령어
`npm outdated`
- 업데이트 누락된 컴포넌트들을 일괄 업데이트하는 명령어
`npm update`
- 모든 프로젝트 의존성 목록을 가져오는 명령어
`npm list`

# AG Grid
`npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`
AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트이다.
- 스프레드 시트처럼 데이터를 표시하는데 이용하며, 상호작용도 가능하다.
- 필터링 / 정렬 / 피벗과 같은 기능들을 포함했다.

```ts
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
};

function App() {
  const [keyword, setKeyword] = useState('');
  const [repodata, setRepodata] = useState<Repository[]>([]);
  const handleClick = () => {
    axios.get<{items: Repository[]}>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error=>console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search ⭐</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
      >
        <AgGridReact rowData={repodata}/>
      </div>

    </div>
  )
}
export default App
```

```tsx
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
```
이상의 import 문들은 ag-grid 컴포넌트 자체와 스타일시트를 가지고 왔다. 그 중에서도 `import 'ag-grid-community/styles/ag-theme-material.css';`은 google에서 권장하는 material style을 가지고 왔음을 뜻한다.
그러니까 사전 정의 스타일을 가지고 옴으로써 css를 최소화했다. 그런데 styles/ag-grid.css를 통해 최소한의 커스터마이징도 할 수 있는데, 이를 style={{height:500, width:850}} 으로 처리했다.
그리고 return 문에 agGridReact 컴포넌트의 추가를 통해 repoData를 가지고 테이블을 작성하려한다. rowData라고 이미 사전에 이름 붙여져있는 속성에 프롭을 전달했다(props drilling 개념). rowData는 객체의 배열을 데이터에 넣을 수 있도록 지원한다.

그리고 ag-grid 컴포넌트 자체는 스타일을 정의하는 div element로 꼭 감싸줘야하기 때문에
```tsx
return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search ⭐</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
      >
        <AgGridReact rowData={repodata}/>
      </div>

    </div>
  )
```
이상과 같은 return문이 작성되었다.
그 다음 과정으로 ag-grid에 이용될 컬럼을 정의할것이다. 컬럼 정의 객체의 배열에 해당하는 columnDefs라는 상태를 정의할 것이다. 그리고 ag-grid는 여기에 이용할 수 있는 ColDef타입을 제공한다(TypeScript로 쓰는 이유). 컬럼객체에서는 필수 field 프롭을 이용하여 데이터 접근자를 정의해야하는데, 여기서는 field 값이 컬럼이 표시해야하는 REST API 응답 데이터의 속성 이름이 될 것이다.


```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css'
import { ColDef, ICellEditorParams } from 'ag-grid-community';

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
};

function App() {
  const [keyword, setKeyword] = useState('');
  const [repodata, setRepodata] = useState<Repository[]>([]);
  const [columnDefs] = useState<ColDef[]>([
    {field: 'id', sortable: true, filter: true},          // 컬럼 1
    {field: 'full_name', sortable: true, filter: true},   // 컬럼 2
    {field: 'html_url', sortable: true, filter: true},    // 컬럼 3
    {
      field: 'full_name',
      cellRenderer: (params: ICellEditorParams) => (
        <button 
          onClick={() => alert(params.value)}>
          Press Me ! ⭐
        </button>
      )
    }

  ]);

  const handleClick = () => {
    axios.get<{items: Repository[]}>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error=>console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search ⭐</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 650}}
      >
        <AgGridReact 
          rowData={repodata}
          columnDefs={columnDefs}
          pagination={true}
          paginationPageSize={5}
        />
          
      </div>

    </div>
  )
}

export default App
```

이상에서 컬럼의 정의 및 거기에 딸려있는 properties를 확인했다. sortable / filter 였고, 그 다음에 추가적인 컬럼을 정의했는데, cellRenderer라는 속성이었다.
그리고 pagenation / pagenamtionPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의했다.
return 문과 colDefs 상태를 둘 다 잘 확인해야한다.

cellRenderer 프롭을 이용하면 테이블 셀의 컨텐츠를 사용자 정의할 수 있다. 이상의 예시에서는 Ag Grid 내의 컬럼에서 버튼을 렌더링하는 예시였다.

cellRenderer 속성의 value는 callback 함수로 이루어져있다. 그리고 매개변수로 params를 받았고, ICellRenderParams Type으로 작성했고, params.value의 값은 field 속성에 정의된 full_name을 썼다. 그래서 버튼을 누르면 full_name이 출력되었다.
컬럼 이름이 너무 field와 동일하게만 되어있다. 그러다보니 column명을 확인해보면 Id / Full_name / Html_url / Full_name으로 Full_name 컬럼이 두 개인 것을 확인할 수 있다. 이를 수정하기 위해서는 `headerName` 속성을 활용할 수 있다.

# Material UI Component 이용
shoppinglist 프로젝트를 생성
React - TypeScript
App.tsx 전부 초기화
npm install @mui/material@5.14.8
npm install @emotion/react@11.11.1
npm install @emotion/styled@11.11.0


```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'

function App() {

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App

```

각 컴포넌트가 무슨 역할을 하는지 보자.
Container는 전체 브라우저 화면을 의미하고, AppBar는 상단을 의미한다. 그리고 ToolBar는 그 중에서도 nav와 비슷한 역할을 한다.
Typography는 글씨 관련 영역을 나타낸다.
이하부터는 실제 shopping list의 기능과 관련된 부분을 작성할 예정이다.
당연히 MUI를 도입한 부분이 될 것이기 때문에 일반적인 html + css + js + react의 형태로는 어떻게 작성될 수 있을지 감안한 상태에서 코드를 확인해야한다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";

function AddItem(props) {

  const [open, setOpen] = useState(false);
  
  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>
    
    </>
  );
}

export default AddItem
```

App 컴포넌트 내에 AddItem 컴포넌트를 추가할것이다. 그런데 우리 todolist할 때는 input 창에 button 하나만 있었다. 그리고 github api 가지고 올 때도 그랬었다. 이번에는 Modal이라고 하는 개념을 추가할 것이다.
Modal을 처음 배우는 건 아니고 1만 시간의 법칙에서 했다.

픔에 product와 amount라는 두 개의 입력 필드와 App 컴포넌트  내에 addItem 함수를 호출하느 버튼을 추가한다. App 컴포넌트에 있는 addItem 함수를  호출할 수 있으려면 addItem 컴포넌트를 렌더링할 때, 프롭으로 전달_해야한다.
모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑 항목을 입력할 수있는 모달 폼을 여는 버튼을 추가해둘것이다. 해당 버튼은 컴포넌트가 처음 렌더링될 때 보이는 유일한 요소에 해당할 것이다. 즉, 최초에 open상태가 false이기때문에 모달 폼은 보이지않고 버튼만 보일것이라는 의미이다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

function AddItem(props) {

  const [open, setOpen] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>

        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```

이상에서 주의해서 봐야할 점은 App.tsx에 정의되어있는 type인 Item을 가지고 왔다는 점이다. 이것은 프로젝트의 사이즈가 매우 작기때문이고, 보통은 type.ts파일에 전체 타입들이 정의되어있고, 거기서 가지고 오게될것이다.
그리고 addItem함수가 App.tsx에 정의되어있지만, AddItem 컴포넌트에서 불러오고있다. 이부분에 대해서 의문을 가질수있다.
1. AddItem 컴포넌트 내에 addItem함수를 정의하면 안되는가?
  - App.tsx의 addItem 함수를 확인하면 Item이 추가되고 기존의 items들을 그대로 스프레드 연산자로 받아온다는 것을 확인할 수 있다.
  - 여기서 중요한 점은 AddItem 컴포넌트에서 하나의 item을 추가한 것을 상위로 보낼 방법이 없다는 것이다.
  - React에서의 Data Flow는 상위 -> 하위로 이어지는 Top-Down 형식이기 때문이다. 즉 AddItem 컴포넌트에서 추가하는 함수를 별개로 만들어봤자 App컴포넌트로 보낼 수 없기때문에 결과적으로 App 컴포넌트에서 addItem 함수를 만들고, _해당함수를 호출하는 함수를 AddItem 컴포넌트에 정의_ 해야한다고 생각할 수있다.
  - React에서의 기초적인 원리 부분에서 One-way data flow에 대해 강조한 이유가 나오는 부분 중 하나이다.
  - 너무 복잡하다면 Recoil / ContextAPI 등의 전역 상태 관리를 통해 함수를 전부 다 전역에 등록해서 불러온는 방법도 고려할 수 있다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

type AddItemProps = {
  addItem: (item: Item) => void;
}

function AddItem(props: AddItemProps) {

  const [open, setOpen] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  // App.tsx의 addItem 함수를 호출하고, item 상태를 전달

  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 다 지우고 Modal을 닫음
    setItem({product: '', amount: ''});
    handleClose();
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>
          <TextField value={item.product} margin="dense"
            onChange={e => setItem({...item, product: e.target.value})}
            label="Product/제품명" fullWidth
          />
          <TextField value={item.amount} margin="dense"
            onChange={e => setItem({...item, amount: e.target.value})}
            label="Amount/수량" fullWidth
          />
        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```

이상의 코드에서 props로 전달하는 함수부분에 주목하자. 이를 위해 AddItemProps라는 type을 선언헀다.
마찬가지로 App.tsx도 확인해야한다. 함수를 전달하기 위한 방식이었다.

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [items, setItems] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
    </Container>
  )
}

export default App
```

그렇다면 현재까지 작성한 것을 기준으로 했을 때 App.tsx에 있는 items 상태가 업데이트된다는 것은 확인할 수 있다.
근데 그 업데이트된 items를 보여주지 못하고있다.
그럼 업데이트된 items의 결과를 보여주는 return 부분에서의 코드가 있어야할 것 같다.

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import {List, ListItem, ListItemText} from '@mui/material';
import './App.css'
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [items, setItems] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
      <List>
          {
          items.map((item, index) => 
            <ListItem key={index} divider>
              <ListItemText
                primary={item.product}
                secondary={item.amount}
              />
            </ListItem>
          )}
        
      </List>
    </Container>
  )
}

export default App
```
이상에서 확인해야 하는 점은 기본적으로 items 상태를 업데이트하는 부분이 어느 부분에 작성되어야하는가이다. 구조는 현재 
App -> AddItem 
컴포넌트 구조로 돼있다. 즉, App 컴포넌트에 items 결과값을 표시할 것이냐, AddItem 컴포넌트에 표시할 것이냐 1/2 확률이라고 볼 수 있다.

심플하게 생각해봤을 때, items 상태가 정의된 곳이 어디일까?
App
그래서 App에 결과값 표시했다.

List 컴포넌트를 App 컴포넌트내에서 렌더링했다. 지금 현재까지 MUI를 보면 위계가 잡혀있다는 것을 알 수 있다.
List -> ListItem -> ListItemText
ul -> li
List 내에서 map() 함수를 활용하여 ListItem 컴포넌트를  생성했다.(ul 내부에서 map함수를 써서 li를 만든것과 동일하다.). 배열이기 때문에 key 프롭이 요구되는 것도 동일하다.
그리고 `<ListItem key={index} divider>`에서 보면 divider라는 속성이 있는데, 얘는 각 항목 끝부분에 구분선을 가지고 온다.
다음에 ListItemText에서 기본 텍스트로 product를 표시하고, 보조텍스트로 amount를 표시했다. 각각 primary/ secondary로 쓰였다. MUI에서 자주 쓰이는 속성이다.
또한 button의 스타일이 있는데, variant="outlined/text/contained"로 쓸 수 있다.
이상의 MUI 라이브러리를 사용하면 리액트 앱에서 일관되게 디자인을 하는 것이 가능하다. 그리고 좋은 점은 프로젝트를 찍어낼 때, CSS를 고려할 필요성이 덜하다는 점이다.
하지만 기본값이 정해져있는 만큼 커스터마이징을 하기 위해서는 emotion이나 tailwind를 고려할 필요도 있다.
다음엔 React Router를 활용하여 라우팅 관리하는 방법을 배우겠다.

# React Router
routerapp project를 생성 React / TypeScript
npm install
npm install react-router-dom@6
App.tsx를 초기화
Home.tsx를 생성하고 초기화
Contact.tsx를 생성하고 초기화

React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅을 구현하는데 이용되는 컴포넌트들을 제공한다. 
1. BrowserRouter : 웹기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의된 컴포넌트를 렌더링
이하는 Route 컴포넌트의 예시인데, element 속성은 사용자가 path 프롭에 정의된 contact 엔드포인트로 이동할 때 렌더링되는 컴포넌트를 정의한다.
경로는 현재 위치를 기준으로 상대 경로를 작성한다.
`<Route path="contact" element={ <Contact/> }/>`
혹은 이하와 같이 path 속성 끝에 * 와일드 카드를 이용하는 것도 가능하다.
`<Route path="/contact/*" element={<Contact/>}/>`
그러면 contact/mike 혹은 contact/1 등의 엔드포인트들에 전부 다 Contact 컴포넌트가 렌더링된다.
또한, Route 컴포넌트는 여러 Route 컴포넌트를 감싸는 것이 가능하다. 이를 위해서 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공하는데 이하의 예시는 Contact 링크를 표시하며, 해당 링크를 클릭했을 때, `/contact`엔드 포인트로 이동한다.
`<Link to="/contact">Contact</Link>`

```tsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import './App.css'
import Contact from './Contact'
import Home from './Home'
import PageNotFound from './PageNotFound'
import ContactSeoul from './ContactSeoul'
import ContactBusan from './ContactBusan'

function App() {

  return (
    <>
      <BrowserRouter>
        <nav>
          <Link to="/">Home</Link>{' | '}
          <Link to="/contact">Contact</Link>
        </nav>
        <Routes>
          <Route path="/" element={<Home />}/>
          <Route path="contact" element={<Contact />}>
            <Route path="seoul" element={<ContactSeoul/>}/>
            <Route path="busan" element={<ContactBusan/>}/>
          </Route>
          <Route path="*" element={<PageNotFound />}/>
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App

// Contact.tsx
import { Link, Outlet } from "react-router-dom";

function Contact() {


  return (
    <>
      <h3>Contact Us ! ⭐</h3>
      <nav>
        <Link to="seoul">서울 지점</Link>{' | '}
        <Link to="busan">부산 지점</Link>
      </nav>
      <hr/>
      <Outlet/>      
    </>
  );
}

export default Contact
```

`<Outlet/>` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 일종의 자리 표시자(placeholder)이다.
그러니까 Outlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러내주세요, 라는 의미가 된다.
그러면 이상의 코드에서 봤던것처럼 App.tsx의 `<Route path="contact" element={<Contact/>}/>`의 내부에 seoul과 busan 엔드포인트를 지정했고, 거기에 ContactSeoul과 ContactBusan을 이미 명시해뒀다. 그렇기 때문에 Contact 컴포넌트 내에서 다시 ContactSeoul 및 ContactBusan을 명시하는 것이 아니라 `<Outlet/>` 컴포넌트를 통해 불러온다고 생각하면 된다.

이상의 라이브러리를 이용할 경우 컴포넌트들이 하나의 URL(예를 들어 localhost:5173)만 가지는 것이 아니라 각각의 다른 URL을 가지도록 통제하여 필요한 부분만 렌더링할 수 있도록 한다.

# 요약
1. 3rd party 컴포넌트들을 학습했다.
  - react-date-picker는 그냥 설치하는 방법 보여줬다.
  - AgGrid를 이용했다.
    - 테이블을 대체하는 컴포넌트
      - filter, sort, column 정의와 관련된 부분을 학습헀다.
    - MUI 컴포넌트
      - 이상에서 중요한 것은 각각의 HTML 태그에 해당하는 컴포넌트들이 존재한다는 점이다.
        - `<input>` 태그를 대체하는 것은 `<TextField>` 인 등
        - 내부에 MUI 자체 property가 있기 때문에 학습 필요성이 있다.
        - CSS보다 훨씬 쉽기때문에 학습하는 중이다.
    - react-router-dom
      - SPA상에서 하나의 URL이 아니라 다수의 URL을 다루는 방식을 학습했다.
      - 조건부 렌더링이 if문이나 삼항연산자를 쓰는 것 뿐만아니라, 내부의 URL을 기준으로 서로 다른 컴포넌트를 렌더링할 수 있도록하는 방식이었다.
  
외부 라이브러리를 다루는 현재 시점에서는 공식문서의 활용이 매우 중요하다. 프로젝트 때 어떤 라이브러리를 다루게 될지 모르기때문이다.

# Full Stack 개발 - 스프링부트 RESTful API 웹 서비스를 위한 프론트엔드
## UI prototype
1. 데이터베이스의 자동차를 데이블에 나열하고, 페이징, sorting, filtering 기능을 구현할 것이다. - AG Grid를 써서
2. 데이터베이스에 새 차량을 추가할 수 있는 모달 폼을 여는 버튼을 구현할 것이다. - MUI를 사용해서
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼을 구현할 것이다. AG Grid에 있었는데, 거기에 버튼 추가했을 때 특정 함수가 호출되고, 그게 백엔드로 전달 -> DB로 들어가서 PUT 혹은 DELETE 메서드를 실행시킬 것이다.
4. CSV 파일로 변형하여 내려받기가 가능한 링크 혹은 버튼을 구현해볼까한다.

## FrontEnd React 프로젝트 생성
carfront project를 생성한다. React / TypeScript
npm install
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @mui/material@5.17.1
npm install @tanstack/react-query@4.36.1
npm install axios@1.9.0
App.tsx를 전체 초기화
npm run dev
git add .
git commit -m "feat: carfront project creation"
git push